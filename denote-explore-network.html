<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Denote Explore {{graph-type}} Network</title>
    <style>
      body {
          font-family: Arial, sans-serif;
          margin: 0;
          padding: 0;
          display: flex;
          justify-content: center;
          align-items: center;
          height: 100vh;
          background-color: #f8f8f8;
      }

      svg {
          border: 0px solid #ccc;
	  z-index: 1;
      }

      .tooltip {
          position: absolute;
          background-color: white;
          border: 1px solid #ddd;
          border-radius: 8px;
          padding: 15px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
          pointer-events: none;
          line-height: 1.4;
          max-width: 600px;
	  z-index: 1000;
      }

      .tooltip .title {
          font-weight: bold;
          margin-bottom: 10px;
	  font-size: 28px;
      }

      .tooltip .keywords {
          display: flex;
          flex-wrap: wrap;
          gap: 5px;
          margin-top: 5px;
      }

      .tooltip .keywords span {
          background-color: #e0e7ff;
          color: #3b82f6;
          padding: 2px 8px;
          border-radius: 4px;
          font-size: 18px;
      }

      .tooltip .metadata {
          margin-top: 10px;
          font-size: 18px;
          color: #555;
      }

      .hidden {
          display: none;
      }
      
      .info-button {
	  position: fixed;
	  top: 10px;
	  left: 10px;
	  width: 50px;
	  height: 50px;
	  background-color: #007BFF;
	  color: white;
	  font-size: 24px;
	  font-weight: bold;
	  text-align: center;
	  line-height: 50px;
	  border-radius: 25px; /* Makes it a circle */
	  cursor: pointer;
	  z-index: 1000;
	  box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.2);
	  transition: transform 0.2s, box-shadow 0.2s;
      }

      .info-button:hover {
	  transform: scale(1.1); /* Slightly enlarges on hover */
	  box-shadow: 0px 6px 8px rgba(0, 0, 0, 0.3); /* More pronounced shadow */
      }

      .info-button:active {
	  transform: scale(0.95); /* Slightly shrinks when clicked */
	  box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.3); /* Subtle shadow on click */
      }

      #info-button:hover .info-tooltip {
	  display: block; /* Show on hover */
      }

      .info-tooltip {
	  position: absolute;
	  top: 60px;
	  left: 10px;
	  background-color: white;
	  color: black;
	  border: 1px solid #ddd;
	  border-radius: 8px;
	  padding: 15px;
	  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
	  max-width: 600px; /* Prevents it from growing too wide */
	  overflow: auto;
	  display: none;
	  z-index: 99999;
      }
      .info-tooltip .title {
          font-weight: bold;
          margin-bottom: 10px;
	  font-size: 24px;
      }

      .info.tooltip .metadata {
          margin-top: 10px;
          font-size: 22px;
          color: #555;
      }

      #keyword-chart svg {
	  font-family: Arial, sans-serif;
      }

      .bar {
	  fill: #3b82f6;
      }

      .bar:hover {
	  fill: #2563eb;
      }

      .axis text {
	  font-size: 12px;
      }

    </style>
  </head>
  <body>
    <div id="info-button" class="info-button">
      â„¹
    </div>
    <div class="info-tooltip">
      <div class="title">Denote <span id="graph-type"></span> Network</div>
      <div class="metadata">Nodes: <span id="node-count"></span></div>
      <div class="metadata">Edges: <span id="edge-count"></span></div>
      <div id="keyword-chart"></div>
    </div>
    <script src="{{d3-js}}"></script>
    <script>
      const data = {{json-content}}

      const width = 1440;
      const height = 900;

      const color = d3.scaleOrdinal(d3.schemeCategory10);
      const links = data.edges; // Array of edges
      const nodes = data.nodes; // Array of nodes

      // Create a tooltip div
      const tooltip = d3.select("body")
	    .append("div")
	    .attr("class", "tooltip hidden");

      // Create a zoom behaviour
      const zoom = d3.zoom()
	    .scaleExtent([0.1, 4]) // Zoom scale limits
	    .on("zoom", (event) => {
		svgGroup.attr("transform", event.transform); // Apply zoom
	    });

      // Create the SVG container with zoom functionality
      const svg = d3.select('body').append("svg")
	    .attr("width", width)
	    .attr("height", height)
	    .attr("viewBox", [0, 0, width, height])
	    .attr("style", "max-width: 100%; height: auto;")
	    .call(zoom);

      const svgGroup = svg.append("g"); // Group to apply zoom transformations
      const radiusScale = d3.scaleLinear()
	    .domain(d3.extent(nodes, d => d.degree)) // Node degree range
	    .range([7, 30]); // Radius range for nodes

      // Define a weight scale for edge stroke width (Keywords only)
      const isKeywordType = data.meta.type === "Keywords";
      const maxWeight = d3.max(links, d => d.weight || 1);

      // Define the weight scale with interpolation
      const weightScale = d3.scaleLinear()
	    .domain([1, maxWeight]) // Map the range of weights
	    .range(isKeywordType ? [2, 30] : [1, 1]); // Adjust the range

      const arrowMarkers = svg.append("defs");

      // Pre-calculate refX for edges
      links.forEach((d, i) => {
	  const targetNode = nodes.find(node => node.id === d.target);
	  const targetRadius = radiusScale(targetNode.degree) + 2; // Same padding as above
	  d.refX = targetRadius; // Dynamically calculate refX for alignment
      });

      // Define arrow markers dynamically based on line weight
      links.forEach((d, i) => {
	  arrowMarkers.append("marker")
              .attr("id", `arrow-${i}`)
              .attr("viewBox", "0 -5 10 10")
              .attr("refX", d.refX) // Use the pre-calculated refX
              .attr("refY", 0)
              .attr("markerWidth", 10) // Adjust arrow size
              .attr("markerHeight", 5) // Adjust arrow size
              .attr("orient", "auto")
              .append("path")
              .attr("d", "M0,-5L10,0L0,5") // Arrow shape
              .attr("fill", "#999")
              .attr("stroke", "none");
      });

      // Add links and use dynamically created markers
      const link = svgGroup.append("g")
	    .attr("stroke", "#999")
	    .attr("stroke-opacity", 0.6)
      // Binding and joining data
    .selectAll("line")
    .data(links)
    .join("line")
      // Styling the links
    .attr("stroke-width", d => weightScale(d.weight || 1))
      // Add arrow markers
    .attr("marker-end", (d, i) => data.meta.directed ? `url(#arrow-${i})` : null)
      
      // Add hover interaction for edges
    .on("mouseover", (event, d) => {
	if (data.meta.type === "Keywords") { // Check if meta.type is "Keyword"
	    // Generate content for the tooltip
	    const tooltipContent = `
      <div class="metadata">From: ${d.source.name}</div>
      <div class="metadata">To: ${d.target.name}</div>
      <div class="metadata">Weight: ${d.weight || 'undefined'}</div>
      `;
	    tooltip
		.classed("hidden", false)
		.html(tooltipContent)
		.style("left", (event.pageX + 10) + "px")
		.style("top", (event.pageY + 10) + "px");
	}
    })
    .on("mouseout", () => {
	tooltip.classed("hidden", true);
    });

      // Add nodes
      const node = svgGroup.append("g")
	    .attr("stroke", "none")
	    .selectAll("circle")
	    .data(nodes)
	    .join("circle")
	    .attr("r", d => radiusScale(d.degree)) // Radius based on degree
	    .attr("fill", d => color(d.type))
	    .on("click", (event, d) => {
		if (!isKeywordType) { // Only open hyperlink if isKeywordType is false
		    window.open(d.filename, "_blank");
		}
	    })
	    .on("mouseover", (event, d) => {
		// Generate tooltip content based on meta.type
		const tooltipContent = data.meta.type === "Keywords"
		      ? `
	    <div class="title">${d.name}</div>
	    <div class="metadata">Degree: ${d.degree}</div>
                      `:
		      // Tooltip for other types
		`
	    <div class="title">${d.name}</div>
	    <div class="metadata">ID: ${d.id}</div>
	    <div class="metadata">Degree: ${d.degree}, Backlinks: ${d.backlinks}</div>
	    <div class="metadata">Type: ${d.type}</div>
	    <div class="metadata">Signature: ${d.signature ? d.signature : 'undefined'}</div>
	    <div class="keywords">${d.keywords && d.keywords.length > 0 ? d.keywords.map(keyword =>
              `<span>${keyword}</span>`).join('') :
              '<div class="metadata">No keywords</div>'}</div>`;

		tooltip
		    .classed("hidden", false)
		    .html(tooltipContent)
		    .style("left", (event.pageX + 10) + "px")
		    .style("top", (event.pageY + 10) + "px");
	    })

	    .on("mouseout", () => {
		tooltip.classed("hidden", true);
	    });

      // Add drag behavior
      node.call(d3.drag()
		.on("start", dragstarted)
		.on("drag", dragged)
		.on("end", dragended));

      // Add labels for nodes with degree > 2
      const labels = svgGroup.append("g")
	    .selectAll("text")
	    .data(nodes.filter(d => d.degree > 2)) // Filter nodes based on degree
	    .join("text")
	    .attr("dx", 10)
	    .attr("dy", ".35em")
	    .style("font-size", "14px")
	    .style("font-family", "Arial, sans-serif")
	    .style("fill", "#333")
	    .text(d => d.name);
      
      // Set up force simulation
      const simulation = d3.forceSimulation(nodes)
	    .force("link", d3.forceLink(links).id(d => d.id).distance(20)) // Link force
	    .force("charge", d3.forceManyBody().strength(-20)) // Repel nodes
	    .force("center", d3.forceCenter(width / 2, height / 2)) // Centering force
	    .force("collide", d3.forceCollide(50)) // Spread out nodes
	    .force("x", d3.forceX(width / 2).strength(0.05)) // Keep nodes near center
	    .force("y", d3.forceY(height / 2).strength(0.05))
	    .on("tick", ticked);

      // Update positions on each tick
      function ticked() {
	  link
              .attr("x1", d => d.source.x)
              .attr("y1", d => d.source.y)
              .attr("x2", d => {
		  const dx = d.target.x - d.source.x;
		  const dy = d.target.y - d.source.y;
		  const distance = Math.sqrt(dx * dx + dy * dy) || 1; // Avoid division by zero
		  const targetRadius = radiusScale(d.target.degree); // Exact node radius
		  const offsetX = (dx / distance) * targetRadius;
		  return d.target.x - offsetX;
              })
              .attr("y2", d => {
		  const dx = d.target.x - d.source.x;
		  const dy = d.target.y - d.source.y;
		  const distance = Math.sqrt(dx * dx + dy * dy) || 1; // Avoid division by zero
		  const targetRadius = radiusScale(d.target.degree); // Exact node radius
		  const offsetY = (dy / distance) * targetRadius;
		  return d.target.y - offsetY;
              });

	  node
              .attr("cx", d => d.x)
              .attr("cy", d => d.y);

	  labels
              .attr("x", d => d.x)
              .attr("y", d => d.y);
      }

      // Drag event handlers
      function dragstarted(event) {
	  if (!event.active) simulation.alphaTarget(0.3).restart();
	  event.subject.fx = event.subject.x;
	  event.subject.fy = event.subject.y;
      }

      function dragged(event) {
	  event.subject.fx = event.x;
	  event.subject.fy = event.y;
      }

      function dragended(event) {
	  if (!event.active) simulation.alphaTarget(0);
	  event.subject.fx = null;
	  event.subject.fy = null;
      }

      // Info Tooltip Data
      document.getElementById('node-count').textContent = data.nodes.length;
      document.getElementById('edge-count').textContent = data.edges.length;
      const graphTypeText = data.meta.type;
      const firstWord = graphTypeText.split(' ')[0];
      document.getElementById('graph-type').textContent = firstWord;

      const keywordCounts = data.nodes.reduce((acc, node) => {
	  (node.keywords || []).forEach(keyword => {
              acc[keyword] = (acc[keyword] || 0) + 1;
	  });
	  return acc;
      }, {});
      
      const infoButton = document.getElementById("info-button");
      const infoTooltip = document.querySelector(".info-tooltip");

      // Handle tooltip hover
      infoButton.addEventListener("mouseover", () => {
	  infoTooltip.style.display = "block";

	  // Check if isKeywordType is true
	  if (!isKeywordType) {
	      // Prepare keyword data
	      const keywordCounts = data.nodes.reduce((acc, node) => {
		  (node.keywords || []).forEach(keyword => {
		      acc[keyword] = (acc[keyword] || 0) + 1;
		  });
		  return acc;
	      }, {});

	      // Convert and sort data by count (descending)
	      const keywordData = Object.entries(keywordCounts)
		    .map(([keyword, count]) => ({ keyword, count }))
		    .sort((a, b) => b.count - a.count); // Sort from high to low

	      // Clear previous chart (if any)
	      d3.select("#keyword-chart").selectAll("*").remove();

	      // Add bar chart inside #keyword-chart
	      const chartWidth = 600;
	      const chartHeight = 600;
	      const margin = { top: 20, right: 10, bottom: 30, left: 100 };

	      const x = d3.scaleLinear()
		    .domain([0, d3.max(keywordData, d => d.count)])
		    .range([0, chartWidth - margin.left - margin.right]);

	      const y = d3.scaleBand()
		    .domain(keywordData.map(d => d.keyword)) // Sorted domain
		    .range([0, chartHeight - margin.top - margin.bottom])
		    .padding(0.1);

	      const svg = d3.select("#keyword-chart")
		    .append("svg")
		    .attr("width", chartWidth)
		    .attr("height", chartHeight)
		    .append("g")
		    .attr("transform", `translate(${margin.left}, ${margin.top})`);

	      svg.selectAll(".bar")
		  .data(keywordData)
		  .enter()
		  .append("rect")
		  .attr("class", "bar")
		  .attr("x", 0)
		  .attr("y", d => y(d.keyword))
		  .attr("width", d => x(d.count))
		  .attr("height", y.bandwidth())
		  .attr("fill", "#3b82f6");

	      // Add x-axis
	      svg.append("g")
		  .attr("transform", `translate(0, ${chartHeight - margin.top - margin.bottom})`)
		  .call(d3.axisBottom(x).ticks(5))
		  .selectAll("text") // Select all text labels
		  .style("font-size", "18px") // Change font size
		  .style("font-family", "Arial, sans-serif"); // Optional: Change font family

	      // Add y-axis
	      svg.append("g")
		  .call(d3.axisLeft(y))
		  .selectAll("text") // Select all text labels
		  .style("font-size", "18px") // Change font size
		  .style("font-family", "Arial, sans-serif"); // Optional: Change font family

	  } else {
              // Clear chart if not isKeywordType
              d3.select("#keyword-chart").selectAll("*").remove();
	  }
      });
      // Hide tooltip on mouseout
      infoButton.addEventListener("mouseout", () => {
	  infoTooltip.style.display = "none";
      });

    </script>
  </body>
</html>
